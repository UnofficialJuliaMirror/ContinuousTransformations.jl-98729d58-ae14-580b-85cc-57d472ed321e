using ContinuousTransformations
import ForwardDiff: derivative
using Cubature
import Base: rand
using Base.Test

"""
Test univariate transformation `f` with `x`. Tests for:

1. type of the transformed value,
2. whether it is in the range,
3. inverse,
4. jacobian determinant and its log using automatic differentiation.
"""
function test_univariate_scalar(f::UnivariateTransformation, x)
    y = f(x)
    @test y ∈ image(f)
    @test inv(f)(y) ≈ x
    (y2, jac) = f(x, JAC)
    @test y == y2
    @test jac ≈ abs(derivative(f, x))
    (y3, logjac) = f(x, LOGJAC)
    @test y == y3
    @test logjac ≈ log(jac)
end

"""
Test that univariate transformations map a Segment the correct way.
"""
function test_univariate_interval(f::UnivariateTransformation, x::Segment)
    y = f(x)
    left, right = f(x.left), f(x.right)
    if right < left
        right, left = left, right
    end
    @test y.left ≈ left
    @test y.right ≈ right
end

# Return a random float in an interval (for testing).
rand(::RealLine) = randn()
rand(ray::PositiveRay) = ray.left + abs(randn())
rand(ray::NegativeRay) = ray.right + abs(randn())
rand(seg::Segment) = seg.left + width(seg) * rand()

"""
Return a function that generates random intervals in the given
interval (for testing).
"""
function random_segment(i::AbstractInterval)
    a, b = [rand(i) for _ in 1:2]
    if a > b
        a, b = b, a
    end
    Segment(a, b)
end

"""
Return a vector of values outside the interval (for testing).
"""
scalars_outside_interval(::RealLine) = []
scalars_outside_interval(ray::PositiveRay) = ray.left - [0.1, 1.0, 2.0, Inf]
scalars_outside_interval(ray::NegativeRay) = ray.right + [0.1, 1.0, 2.0, Inf]
function scalars_outside_interval(seg::Segment)
    vcat(scalars_outside_interval(PositiveRay(seg.left)),
         scalars_outside_interval(NegativeRay(seg.right)))
end

"""
Test univariate transformation `f`, called with random numbers and
intervals generated by `randform`, which should return numbers in the
domain.
"""
function test_univariate(f, N=500)
    dom = domain(f)
    for i in 1:500
        test_univariate_scalar(f, rand(dom))
    end
    for i in 1:500
        test_univariate_interval(f, random_segment(dom))
    end
    for x in scalars_outside_interval(dom)
        @test_throws DomainError f(x)
    end
end

@testset "Univariate transformations" begin
    test_univariate(Logit())
    test_univariate(Logistic())
    test_univariate(Log())
    test_univariate(Exp())
    test_univariate(OddsRatio())
    test_univariate(InvOddsRatio())
    for _ in 1:100
        test_univariate(Power(abs(randn())), 10)
    end
    for _ in 1:10
        a = Affine(randn(), randn())
        test_univariate(a, 10)
    end
end

@testset "Univariate integral" begin
    f, dom = integral_substitution(InvOddsRatio(), x->exp(-x^2), 0..Inf)
    @test hquadrature(f, dom.left, dom.right)[1] ≈ √π/2
end
