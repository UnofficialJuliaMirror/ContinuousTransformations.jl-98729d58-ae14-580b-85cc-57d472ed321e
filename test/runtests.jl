using ContinuousTransformations
using ValidatedNumerics
using Base.Test
import ForwardDiff: derivative
using Cubature

"""
Test univariate transformation `f` with `x`. Tests for:

1. type of the transformed value,
2. whether it is in the range,
3. inverse,
4. jacobian determinant and its log using automatic differentiation.
"""
function test_univariate_scalar(f::UnivariateTransformation, x)
    y = f(x)
    @test isa(y, typeof(x))
    @test y ∈ f(domain(f))
    @test inv(f)(y) ≈ x
    (y2, jac) = f(x, JAC)
    @test y == y2
    @test jac ≈ abs(derivative(f, x))
    (y3, logjac) = f(x, LOGJAC)
    @test y == y3
    @test logjac ≈ log(jac)
end

"""
Test that univariate transformations map an interval the correct way.
"""
function test_univariate_interval(f::UnivariateTransformation, x::Interval)
    y = f(x)
    f_lo, f_hi = f(x.lo), f(x.hi)
    if f_lo > f_hi
        f_lo, f_hi = f_hi, f_lo
    end
    y2 = f_lo..f_hi             # constructor handles rounding
    @test y.lo ≈ y2.lo
    @test y.hi ≈ y2.hi
end

"Return a random float in an interval (for testing)."
function random_scalar_in_interval(i::Interval)
    if isentire(i)
        randn()
    elseif i.hi == Inf
        i.lo + abs(randn())
    elseif i.lo == -Inf
        i.hi - abs(randn())
    else
        i.lo + diam(i)*rand()
    end
end

"""
Return a function that generates random intervals in the given
interval (for testing).
"""
function random_interval_in_interval(i::Interval)
    a, b = [random_scalar_in_interval(i) for _ in 1:2]
    if a > b
        a, b = b, a
    end
    Interval(a, b)
end

"""
Return a vector of values outside the interval (for testing).
"""
function scalars_outside_interval(i::Interval)
    xs = [0.1, 1.0, 2.0, Inf]
    if isentire(i)
        []
    elseif i.hi == Inf
        i.lo - xs
    elseif i.lo == -Inf
        i.hi + xs
    else
        vcat(i.lo - xs, i.hi + xs)
    end
end

"""
Test univariate transformation `f`, called with random numbers and
intervals generated by `randform`, which should return numbers in the
domain.
"""
function test_univariate(f, N=500)
    dom = domain(f)
    for i in 1:500
        test_univariate_scalar(f, random_scalar_in_interval(dom))
    end
    for i in 1:500
        test_univariate_interval(f, random_interval_in_interval(dom))
    end
    for x in scalars_outside_interval(dom)
        @test_throws DomainError f(x)
    end
end

@testset "Univariate transformations" begin
    test_univariate(Logit())
    test_univariate(Logistic())
    test_univariate(Log())
    test_univariate(Exp())
    test_univariate(OddsRatio())
    test_univariate(InvOddsRatio())
    for _ in 1:100
        test_univariate(Power(abs(randn())), 10)
    end
    for _ in 1:10
        a = Affine(randn(), randn())
        test_univariate(a, 10)
    end
end

@testset "Univariate integral" begin
    f, dom = integral_substitution(InvOddsRatio(), x->exp(-x^2), 0..Inf)
    @test hquadrature(f, dom.lo, dom.hi)[1] ≈ √π/2
end
